#!/usr/bin/env python3
"""
Generate three types of plots:
1. Number of Nodes vs Latency (s) for two B values (100, 1000)
2. Batch size (txs) vs Latency (s) for two network size N values (16, 31)
3. Batch size vs Throughput (txs/s) for two network size N values (16, 31)

Requires: matplotlib, pandas (install via pip install matplotlib pandas)
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import os
import sys

# Set style for academic plots
plt.style.use('seaborn-v0_8-whitegrid')
matplotlib.rcParams.update({
    'font.size': 11,
    'axes.titlesize': 12,
    'axes.labelsize': 11,
    'xtick.labelsize': 10,
    'ytick.labelsize': 10,
    'legend.fontsize': 10,
    'figure.figsize': (10, 8),
    'figure.dpi': 300,
    'savefig.dpi': 300,
})

# Colors for protocols
PROTOCOL_COLORS = {
    'hmvba': '#1f77b4',        # blue
    'dumbomvbastar': '#ff7f0e', # orange
    'finmvba': '#2ca02c',       # green
}

PROTOCOL_LABELS = {
    'hmvba': 'H-MVBA',
    'dumbomvbastar': 'Dumbo-MVBA*',
    'finmvba': 'FIN-MVBA',
}

def load_data():
    """Load CSV files generated by analysis scripts."""
    latency_csv = 'plot_latency_vs_b.csv'
    throughput_csv = 'plot_throughput_vs_n.csv'
    
    if not os.path.exists(latency_csv):
        print(f"Error: {latency_csv} not found. Run analyze_results.py first.")
        sys.exit(1)
    if not os.path.exists(throughput_csv):
        print(f"Error: {throughput_csv} not found. Run analyze_results.py first.")
        sys.exit(1)
    
    latency_df = pd.read_csv(latency_csv)
    throughput_df = pd.read_csv(throughput_csv)
    
    # Convert B to input size in KB (paper uses L = 250*B bytes)
    # L in KB = 250 * B / 1024
    latency_df['input_size_kb'] = 250 * latency_df['B'] / 1024
    
    return latency_df, throughput_df

def load_aggregated_data():
    """Load aggregated results CSV for throughput vs B data."""
    aggregated_csv = 'aggregated_results.csv'
    if not os.path.exists(aggregated_csv):
        print(f"Warning: {aggregated_csv} not found. Some plots may be limited.")
        return None
    
    agg_df = pd.read_csv(aggregated_csv)
    # Filter out rows with missing tps_mean or latency_mean
    agg_df = agg_df.dropna(subset=['tps_mean', 'latency_mean'])
    # Filter out B=0 (zero batch size)
    agg_df = agg_df[agg_df['B'] > 0]
    return agg_df

def plot_figure2(latency_df, output_dir='plots'):
    """Figure 2: Latency vs. Batch Size - separate figures for N=16 and N=31."""
    os.makedirs(output_dir, exist_ok=True)
    
    n_values = [16, 31]
    
    for n_val in n_values:
        plt.figure()
        
        for protocol in latency_df['protocol'].unique():
            df_n = latency_df[latency_df['N'] == n_val].copy()
            proto_df = df_n[df_n['protocol'] == protocol].sort_values('B')
            # Filter out B=0 rows
            proto_df = proto_df[proto_df['B'] > 0]
            if len(proto_df) < 2:
                continue
            
            plt.errorbar(
                x=proto_df['B'],
                y=proto_df['latency_mean'],
                yerr=proto_df['latency_std'],
                label=PROTOCOL_LABELS.get(protocol, protocol),
                color=PROTOCOL_COLORS.get(protocol, 'gray'),
                marker='o',
                capsize=4,
                linewidth=1.5,
            )
        
        plt.xlabel('Batch Size (transactions)')
        plt.ylabel('Latency (seconds)')
        plt.title(f'Latency vs. Batch Size (N={n_val})')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # Use log scale for x-axis (batch size) as values span orders of magnitude
        plt.xscale('log')
        # Set custom x-ticks to match actual B values
        plt.xticks([10, 100, 1000, 7000], ['10', '100', '1000', '7000'])
        
        plt.tight_layout()
        output_path = os.path.join(output_dir, f'figure2_latency_vs_batch_size_N{n_val}.png')
        plt.savefig(output_path)
        print(f"Saved {output_path}")
        plt.close()

def plot_figure3(agg_df, output_dir='plots'):
    """Figure 3: Throughput vs. Batch Size - separate figures for N=16 and N=31."""
    os.makedirs(output_dir, exist_ok=True)
    
    if agg_df is None or agg_df.empty:
        print("Warning: No aggregated data available for throughput vs batch size plot.")
        return
    
    n_values = [16, 31]
    
    for n_val in n_values:
        plt.figure()
        
        for protocol in agg_df['protocol'].unique():
            df_n = agg_df[agg_df['N'] == n_val].copy()
            proto_df = df_n[df_n['protocol'] == protocol].sort_values('B')
            if len(proto_df) < 2:
                continue
            
            plt.errorbar(
                x=proto_df['B'],
                y=proto_df['tps_mean'],
                yerr=proto_df['tps_std'],
                label=PROTOCOL_LABELS.get(protocol, protocol),
                color=PROTOCOL_COLORS.get(protocol, 'gray'),
                marker='s',
                capsize=4,
                linewidth=1.5,
            )
        
        plt.xlabel('Batch Size (transactions)')
        plt.ylabel('Throughput (transactions per second)')
        plt.title(f'Throughput vs. Batch Size (N={n_val})')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # Use log scale for x-axis (batch size)
        plt.xscale('log')
        plt.xticks([10, 100, 1000, 7000], ['10', '100', '1000', '7000'])
        
        plt.tight_layout()
        output_path = os.path.join(output_dir, f'figure3_throughput_vs_batch_size_N{n_val}.png')
        plt.savefig(output_path)
        print(f"Saved {output_path}")
        plt.close()

def plot_figure4(latency_df, output_dir='plots'):
    """Figure 4: Latency vs. Number of Nodes - separate figures for B=100 and B=1000."""
    os.makedirs(output_dir, exist_ok=True)
    
    b_values = [100, 1000]
    
    for b_val in b_values:
        plt.figure()
        
        for protocol in latency_df['protocol'].unique():
            df_b = latency_df[latency_df['B'] == b_val].copy()
            proto_df = df_b[df_b['protocol'] == protocol].sort_values('N')
            if len(proto_df) < 2:
                continue
            
            plt.errorbar(
                x=proto_df['N'],
                y=proto_df['latency_mean'],
                yerr=proto_df['latency_std'],
                label=PROTOCOL_LABELS.get(protocol, protocol),
                color=PROTOCOL_COLORS.get(protocol, 'gray'),
                marker='^',
                capsize=4,
                linewidth=1.5,
            )
        
        plt.xlabel('Number of Nodes (N)')
        plt.ylabel('Latency (seconds)')
        plt.title(f'Latency vs. Number of Nodes (B={b_val})')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        plt.xticks(sorted(latency_df['N'].unique()))
        
        plt.tight_layout()
        output_path = os.path.join(output_dir, f'figure4_latency_vs_nodes_B{b_val}.png')
        plt.savefig(output_path)
        print(f"Saved {output_path}")
        plt.close()

def plot_additional_comparisons(latency_df, throughput_df, output_dir='plots'):
    """Additional plots: Speedup comparisons, etc."""
    os.makedirs(output_dir, exist_ok=True)
    
    # 1. Speedup heatmap or bar chart
    # For N=31, compute speedup of H-MVBA vs each baseline
    n_val = 31
    df_n31 = latency_df[latency_df['N'] == n_val].copy()
    
    # Group by B and protocol, exclude B=0
    speedups = []
    for b_val in sorted(df_n31['B'].unique()):
        if b_val == 0:
            continue
        b_df = df_n31[df_n31['B'] == b_val]
        if len(b_df) < 3:
            continue
        
        hmvba_lat = b_df[b_df['protocol'] == 'hmvba']['latency_mean'].values
        dumb_lat = b_df[b_df['protocol'] == 'dumbomvbastar']['latency_mean'].values
        fin_lat = b_df[b_df['protocol'] == 'finmvba']['latency_mean'].values
        
        if len(hmvba_lat) > 0 and len(dumb_lat) > 0:
            speedup_dumb = dumb_lat[0] / hmvba_lat[0] if hmvba_lat[0] > 0 else 1
            speedups.append({'B': b_val, 'Baseline': 'Dumbo-MVBA*', 'Speedup': speedup_dumb})
        if len(hmvba_lat) > 0 and len(fin_lat) > 0:
            speedup_fin = fin_lat[0] / hmvba_lat[0] if hmvba_lat[0] > 0 else 1
            speedups.append({'B': b_val, 'Baseline': 'FIN-MVBA', 'Speedup': speedup_fin})
    
    if speedups:
        speedup_df = pd.DataFrame(speedups)
        
        plt.figure()
        import seaborn as sns
        # Bar plot
        ax = sns.barplot(data=speedup_df, x='B', y='Speedup', hue='Baseline')
        ax.axhline(y=1.0, color='gray', linestyle='--', alpha=0.5)
        plt.xlabel('Batch Size (B)')
        plt.ylabel('Speedup (Baseline Latency / H-MVBA Latency)')
        plt.title(f'Speedup of H-MVBA vs Baselines (N={n_val})')
        plt.legend(title='Baseline')
        plt.tight_layout()
        output_path = os.path.join(output_dir, f'speedup_bar_N{n_val}.png')
        plt.savefig(output_path)
        print(f"Saved {output_path}")
        plt.close()
    
    # 2. Throughput vs Input Size for N=31
    # Not enough data in current CSVs, skip

def main():
    print("Loading data...")
    latency_df, throughput_df = load_data()
    agg_df = load_aggregated_data()
    
    print("Generating Figure 2 (Latency vs Batch Size for N=16 and N=31)...")
    plot_figure2(latency_df)
    
    print("Generating Figure 3 (Throughput vs Batch Size for N=16 and N=31)...")
    plot_figure3(agg_df)
    
    print("Generating Figure 4 (Latency vs Number of Nodes for B=100 and B=1000)...")
    plot_figure4(latency_df)
    
    print("Generating additional comparison plots...")
    plot_additional_comparisons(latency_df, throughput_df)
    
    print("\nAll plots saved to 'plots/' directory.")
    print("Note: These plots are based on 53/90 completed experiments.")
    print("Missing data for N=61,101 baselines and N=201 all protocols.")

if __name__ == '__main__':
    main()