#!/usr/bin/env python3
"""
Generate plots similar to paper Figures 2-4 from CSV data.
Requires: matplotlib, pandas (install via pip install matplotlib pandas)
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import os
import sys

# Set style for academic plots
plt.style.use('seaborn-v0_8-whitegrid')
matplotlib.rcParams.update({
    'font.size': 11,
    'axes.titlesize': 12,
    'axes.labelsize': 11,
    'xtick.labelsize': 10,
    'ytick.labelsize': 10,
    'legend.fontsize': 10,
    'figure.figsize': (10, 8),
    'figure.dpi': 300,
    'savefig.dpi': 300,
})

# Colors for protocols
PROTOCOL_COLORS = {
    'hmvba': '#1f77b4',        # blue
    'dumbomvbastar': '#ff7f0e', # orange
    'finmvba': '#2ca02c',       # green
}

PROTOCOL_LABELS = {
    'hmvba': 'H-MVBA',
    'dumbomvbastar': 'Dumbo-MVBA*',
    'finmvba': 'FIN-MVBA',
}

def load_data():
    """Load CSV files generated by analysis scripts."""
    latency_csv = 'plot_latency_vs_b.csv'
    throughput_csv = 'plot_throughput_vs_n.csv'
    
    if not os.path.exists(latency_csv):
        print(f"Error: {latency_csv} not found. Run analyze_results.py first.")
        sys.exit(1)
    if not os.path.exists(throughput_csv):
        print(f"Error: {throughput_csv} not found. Run analyze_results.py first.")
        sys.exit(1)
    
    latency_df = pd.read_csv(latency_csv)
    throughput_df = pd.read_csv(throughput_csv)
    
    # Convert B to input size in KB (paper uses L = 250*B bytes)
    # L in KB = 250 * B / 1024
    latency_df['input_size_kb'] = 250 * latency_df['B'] / 1024
    
    return latency_df, throughput_df

def plot_figure2(latency_df, output_dir='plots'):
    """Figure 2: Latency vs. input size for N=31."""
    os.makedirs(output_dir, exist_ok=True)
    
    n_val = 31
    df_n31 = latency_df[latency_df['N'] == n_val].copy()
    
    if df_n31.empty:
        print(f"Warning: No data for N={n_val} in latency CSV")
        return
    
    plt.figure()
    
    for protocol in df_n31['protocol'].unique():
        proto_df = df_n31[df_n31['protocol'] == protocol].sort_values('B')
        if len(proto_df) < 2:
            continue
        
        plt.errorbar(
            x=proto_df['input_size_kb'],
            y=proto_df['latency_mean'],
            yerr=proto_df['latency_std'],
            label=PROTOCOL_LABELS.get(protocol, protocol),
            color=PROTOCOL_COLORS.get(protocol, 'gray'),
            marker='o',
            capsize=4,
            linewidth=1.5,
        )
    
    plt.xlabel('Input Size (KB)')
    plt.ylabel('Latency (seconds)')
    plt.title(f'Latency vs. Input Size (N={n_val})')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    # Set x-axis to log scale for input size (paper uses linear? Actually B values are 0,10,100,1000,7000)
    # Use linear scale but with custom ticks
    plt.xticks(sorted(df_n31['input_size_kb'].unique()))
    
    plt.tight_layout()
    output_path = os.path.join(output_dir, f'figure2_latency_vs_input_N{n_val}.png')
    plt.savefig(output_path)
    print(f"Saved {output_path}")
    plt.close()

def plot_figure3(throughput_df, output_dir='plots'):
    """Figure 3: Throughput vs. scale for B=1000."""
    os.makedirs(output_dir, exist_ok=True)
    
    # We need throughput data for B=1000, but our throughput CSV is aggregated by N
    # Actually throughput CSV contains TPS for each protocol at each N (aggregated across B?)
    # Need to check: throughput CSV appears to be for B=1000? Let's assume it's for B=1000.
    # We'll plot TPS vs N for each protocol.
    
    plt.figure()
    
    for protocol in throughput_df['protocol'].unique():
        proto_df = throughput_df[throughput_df['protocol'] == protocol].sort_values('N')
        if len(proto_df) < 2:
            continue
        
        plt.errorbar(
            x=proto_df['N'],
            y=proto_df['tps_mean'],
            yerr=proto_df['tps_std'],
            label=PROTOCOL_LABELS.get(protocol, protocol),
            color=PROTOCOL_COLORS.get(protocol, 'gray'),
            marker='s',
            capsize=4,
            linewidth=1.5,
        )
    
    plt.xlabel('Number of Parties (N)')
    plt.ylabel('Throughput (TPS)')
    plt.title('Throughput vs. Scale (B=1000)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    # Set x-axis to log scale for N (paper uses linear)
    plt.xticks(sorted(throughput_df['N'].unique()))
    
    plt.tight_layout()
    output_path = os.path.join(output_dir, 'figure3_throughput_vs_scale.png')
    plt.savefig(output_path)
    print(f"Saved {output_path}")
    plt.close()

def plot_figure4(latency_df, output_dir='plots'):
    """Figure 4: Latency vs. scale for B=1000."""
    os.makedirs(output_dir, exist_ok=True)
    
    b_val = 1000
    df_b1000 = latency_df[latency_df['B'] == b_val].copy()
    
    if df_b1000.empty:
        print(f"Warning: No data for B={b_val} in latency CSV")
        return
    
    plt.figure()
    
    for protocol in df_b1000['protocol'].unique():
        proto_df = df_b1000[df_b1000['protocol'] == protocol].sort_values('N')
        if len(proto_df) < 2:
            continue
        
        plt.errorbar(
            x=proto_df['N'],
            y=proto_df['latency_mean'],
            yerr=proto_df['latency_std'],
            label=PROTOCOL_LABELS.get(protocol, protocol),
            color=PROTOCOL_COLORS.get(protocol, 'gray'),
            marker='^',
            capsize=4,
            linewidth=1.5,
        )
    
    plt.xlabel('Number of Parties (N)')
    plt.ylabel('Latency (seconds)')
    plt.title(f'Latency vs. Scale (B={b_val})')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    plt.xticks(sorted(df_b1000['N'].unique()))
    
    plt.tight_layout()
    output_path = os.path.join(output_dir, f'figure4_latency_vs_scale_B{b_val}.png')
    plt.savefig(output_path)
    print(f"Saved {output_path}")
    plt.close()

def plot_additional_comparisons(latency_df, throughput_df, output_dir='plots'):
    """Additional plots: Speedup comparisons, etc."""
    os.makedirs(output_dir, exist_ok=True)
    
    # 1. Speedup heatmap or bar chart
    # For N=31, compute speedup of H-MVBA vs each baseline
    n_val = 31
    df_n31 = latency_df[latency_df['N'] == n_val].copy()
    
    # Group by B and protocol
    speedups = []
    for b_val in sorted(df_n31['B'].unique()):
        b_df = df_n31[df_n31['B'] == b_val]
        if len(b_df) < 3:
            continue
        
        hmvba_lat = b_df[b_df['protocol'] == 'hmvba']['latency_mean'].values
        dumb_lat = b_df[b_df['protocol'] == 'dumbomvbastar']['latency_mean'].values
        fin_lat = b_df[b_df['protocol'] == 'finmvba']['latency_mean'].values
        
        if len(hmvba_lat) > 0 and len(dumb_lat) > 0:
            speedup_dumb = dumb_lat[0] / hmvba_lat[0] if hmvba_lat[0] > 0 else 1
            speedups.append({'B': b_val, 'Baseline': 'Dumbo-MVBA*', 'Speedup': speedup_dumb})
        if len(hmvba_lat) > 0 and len(fin_lat) > 0:
            speedup_fin = fin_lat[0] / hmvba_lat[0] if hmvba_lat[0] > 0 else 1
            speedups.append({'B': b_val, 'Baseline': 'FIN-MVBA', 'Speedup': speedup_fin})
    
    if speedups:
        speedup_df = pd.DataFrame(speedups)
        
        plt.figure()
        import seaborn as sns
        # Bar plot
        ax = sns.barplot(data=speedup_df, x='B', y='Speedup', hue='Baseline')
        ax.axhline(y=1.0, color='gray', linestyle='--', alpha=0.5)
        plt.xlabel('Batch Size (B)')
        plt.ylabel('Speedup (Baseline Latency / H-MVBA Latency)')
        plt.title(f'Speedup of H-MVBA vs Baselines (N={n_val})')
        plt.legend(title='Baseline')
        plt.tight_layout()
        output_path = os.path.join(output_dir, f'speedup_bar_N{n_val}.png')
        plt.savefig(output_path)
        print(f"Saved {output_path}")
        plt.close()
    
    # 2. Throughput vs Input Size for N=31
    # Not enough data in current CSVs, skip

def main():
    print("Loading data...")
    latency_df, throughput_df = load_data()
    
    print("Generating Figure 2 (Latency vs Input Size for N=31)...")
    plot_figure2(latency_df)
    
    print("Generating Figure 3 (Throughput vs Scale for B=1000)...")
    plot_figure3(throughput_df)
    
    print("Generating Figure 4 (Latency vs Scale for B=1000)...")
    plot_figure4(latency_df)
    
    print("Generating additional comparison plots...")
    plot_additional_comparisons(latency_df, throughput_df)
    
    print("\nAll plots saved to 'plots/' directory.")
    print("Note: These plots are based on 53/90 completed experiments.")
    print("Missing data for N=61,101 baselines and N=201 all protocols.")

if __name__ == '__main__':
    main()